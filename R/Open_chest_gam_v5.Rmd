---
title: "GAM for thoracotomy waveforms"
output: html_document
editor_options: 
  chunk_output_type: console
---

```{r message=FALSE, warning=FALSE}
rm(list = ls()) # clearing workspace
library(viridis)
library(waveformtools)
library(tidyverse)
library(mgcv)
library(hms)
library(shiny)
library(shinythemes)
library(shinyTime)
library(data.table)
library(readr)
library(dygraphs)
library(dplyr)
library(ggpubr)
library(gridExtra)
```

Functions:

```{r}
pt_range <- c(2, 3, 4) #seq(1,61) # insert the number of the patient you want to visualize

load_patient <- function(patient_number){
    # a function that loads GAMs in RDS file format using a specific nomenclature
    ptopen <- readRDS(paste0("../GAM_RDS/",patient_number, "OPEN.rds"))
    ptclosed <- readRDS(paste0("../GAM_RDS/",patient_number, "CLOSED.rds"))
    pt <- list("ptopen" = ptopen, "ptclosed" = ptclosed)
    return(pt)
}


gen_predictions <- function(cvp_gam) {
    # a function that generates predictions according to the given model
    # the code is a slightly modified version of Johannes'
    if (is.null(cvp_gam)) return(NULL)
    
    #find max of insp_index smooth
    #insp_rel_index_smooth <- gratia::evaluate_smooth(cvp_gam, 's(insp_rel_index)')
    #insp_rel_index_max <- insp_rel_index_smooth$insp_rel_index[which.max(insp_rel_index_smooth$est)]

    structured_data <- expand.grid(insp_rel_index = c(
        # Generate predictions for 10 levels of inspiration between start and max inspiration
        seq(0, 0.9, length.out = 10)), #insp_rel_index_max, length.out = 10)), 
        # And 1 prediction 1 sec after max inspiration                                      
        #insp_rel_index_max + c(1)), # uncommented for our use case
        # Generate 200 predictions uniformaly across the qrs_rel_index (to get a smooth line)
        qrs_rel_index = seq(0,1, length.out = 500),
        # Choose 'some' position for the trend smooth (or better, do not include it in the prediction)
        time_s = 580)
    
    struct_pred <- predict(cvp_gam, newdata = structured_data, se.fit = TRUE, exclude='s(time_s)') 
    
    mutate(structured_data, 
           CVP = struct_pred$fit,
           CVP_low = CVP - 1.96 * struct_pred$se.fit,
           CVP_up = CVP + 1.96 * struct_pred$se.fit)
}


create_patient_preds <- function(ptopen, ptclosed){
    # a function that creates predictions and combines data from closed and open chest into one data frame 
    pred_open <- gen_predictions(ptopen)
    pred_closed <- gen_predictions(ptclosed)
    pred_both <- cbind(indicator=c(rep("open_chest", nrow(pred_open)),
                                   rep("closed_chest", nrow(pred_closed))),
                       pred_both <- rbind(pred_open, pred_closed))
    return(pred_both)
}


stacked_plot <- function(io, ic, qo, qc, patient_number = NULL){
  colnames(io)[3] <- "rel_index"
  colnames(ic)[3] <- "rel_index"
  colnames(qo)[3] <- "rel_index"
  colnames(qc)[3] <- "rel_index"
  
  comb <- cbind(indicator=c(rep("open_chest", nrow(io)),
                            rep("closed_chest", nrow(ic))),
                both <- rbind(io, ic, qo, qc))

  viz <- ggplot(data=comb, aes(x=rel_index, y=est, group=indicator)) +
    geom_line(aes(color=indicator), size = 0.9) +
    facet_wrap(~ smooth) +
    labs(title = "The marginal effects of respiration and QRS, respectively, on CVP",
         y="Estimated effect on CVP",
         x="Relative respiration/QRS index",
         color = "Time period") +
    theme(axis.title.y = element_text(margin = margin(t = 0, r = 15, b = 0, l = 0)))
  return(viz)
}


create_contour_patient <- function(odata, cdata){
  gather_in_one <- rbind(odata, cdata)
  gather_in_one$indicator <- cbind(c(rep("open_chest", nrow(odata)),
                                     rep("closed_chest", nrow(cdata))))
  return(gather_in_one)
}


create_contour_viz <- function(gather_in_one, patient_number = NULL){
  viz <- ggplot(gather_in_one, aes(qrs_rel_index, insp_rel_index, z = est)) +
    geom_raster(aes(fill = est)) +
    geom_contour(colour = "black") +
    scale_fill_gradientn(colours=c("#0000FFFF","#FFFFFFFF","#FF0000FF")) +
      labs(title = "Effect of interaction term between respiration and QRS on CVP",
           y = "Relative respiration index",
           x = "Relative QRS index",
           fill = "Estimated effect\non CVP") +
      facet_wrap(~ indicator) +
    theme(axis.title.y = element_text(margin = margin(t = 0, r = 5, b = 0, l = 0)))
  return(viz)
}


create_viz <- function(pred_both, patient_number = NULL){
    # a function that creates a visualization comparing closed and open predictions  
    viz <- ggplot(data = pred_both, aes(x=qrs_rel_index, y=CVP, group = insp_rel_index)) +
      geom_line(aes(color=insp_rel_index), size = 0.9) +
      scale_color_gradientn(colours = turbo(10)) +
      labs(title = "Change in CVP as a function of relative QRS index at selected relative respiration index times",
           y = "CVP",
           x = "Relative QRS index",
           colour = "Relative        \nrespiration index") +
      facet_wrap(~ indicator) +
      theme(axis.title.y = element_text(margin = margin(t = 0, r = 15, b = 0, l = 0)))
    return(viz)
}


give_it_center <- function(data_set, center = 50){
  
  if (which.max(data_set$est) > center ){
    biggest <- which.max(data_set$est)
    
    value_to_subtract <- data_set$insp_rel_index[biggest] - data_set$insp_rel_index[center]
    
    data_set$insp_rel_index <- data_set$insp_rel_index - value_to_subtract
  
    for (index in 1:length(data_set$insp_rel_index)) {
      if (data_set$insp_rel_index[index] < 0 ){
        data_set$insp_rel_index[index] <- data_set$insp_rel_index[index] +1
      }
    }
  } else{
    smallest <- which.max(data_set$est)
    
    value_to_add <- data_set$insp_rel_index[center] - data_set$insp_rel_index[smallest]
    
    data_set$insp_rel_index <- data_set$insp_rel_index + value_to_add
  
    for (index in 1:length(data_set$insp_rel_index)) {
      if (data_set$insp_rel_index[index] > 1 ){
        data_set$insp_rel_index[index] <- data_set$insp_rel_index[index] -1
      }
    }
  }
  return(data_set)
}
insp_add_sub_val <- function(data_set, center = 50){
  if (which.max(data_set$est) > center ){
    biggest <- which.max(data_set$est)
    value_to_subtract <- data_set$insp_rel_index[center] - data_set$insp_rel_index[biggest]
    return(value_to_subtract)
  }else{
    smallest <- which.max(data_set$est)
    value_to_add <- data_set$insp_rel_index[center] - data_set$insp_rel_index[smallest]
    return(value_to_add)
  }
}

insp_shift_data <- function(data_set, shift_value_open, shift_value_closed){
  data_set <- mutate(data_set, insp_rel_index = ifelse(indicator=="open_chest",
                                                       (data_set$insp_rel_index + shift_value_open) %% 1,
                                                       (data_set$insp_rel_index + shift_value_closed) %% 1))
  
#  data_set$insp_rel_index <- (data_set$insp_rel_index + shift_value_open) %% 1
  return(data_set)
}

move_kontour <- function(data_contour, input_scale_open, input_scale_closed){
  data_contour <- mutate(data_contour,
                         est = c(est[((100 - input_scale_open) * 100 + 1):10000],
                                 est[1:((100 - input_scale_open) * 100)],
                                 est[((100 - input_scale_closed) * 100 + 10001):20000],
                                 est[10001:((100 - input_scale_closed) * 100 + 10000)]))
  return(data_contour)
}

```

Testing area:

```{r}
testpt <- "pt02"
center_open <- 25
center_closed <- 25

patient_path_open <- paste("../GAM_RDS/", testpt, "OPEN.rds",sep="")
pt_data_open <- readRDS(patient_path_open, refhook = NULL)
  
patient_path_closed <- paste("../GAM_RDS/", testpt, "CLOSED.rds",sep="")
pt_data_closed <- readRDS(patient_path_closed, refhook = NULL)


a <- create_contour_patient(pt_data_open, pt_data_closed)


# For snap plots
preds <- create_patient_preds(ptopen = pt_data_open, ptclosed = pt_data_closed)
snapplot <- create_viz(pred_both = preds,
                       patient_number = toString(strtoi(str_sub(testpt,-2))))

# For stacked INSP/QRS plots
stackedplotINSP <- ggplot() +
  geom_line(data=give_it_center(gratia::evaluate_smooth(pt_data_open,'s(insp_rel_index)'),center_open),
            aes(insp_rel_index,est, colour="open")) +
  geom_line(data=give_it_center(gratia::evaluate_smooth(pt_data_closed,'s(insp_rel_index)'),center_closed),
            aes(insp_rel_index,est, colour="closed")) +
  scale_color_manual(values = c('open' = 'darkblue',
                                'closed' = 'red')) +
  theme(legend.position = "none") +
  ggtitle("INSP")

```



Shiny below:

```{r shiny app}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
table_values <- read_csv("../GAM_RDS/CV_MAE.csv") 

patient_list <- paste('pt', str_pad(seq(1,61), 2, pad = "0"), sep = "")

ui <- fluidPage(theme = shinytheme("sandstone"),
  navbarPage("GAM on heart-lung interaction during thoractomy", # Page header
    
    # First page begins
    tabPanel("Main page",
        
        # Parameters
        sidebarPanel(h3("Inputs"),
                     selectInput("patient", label = "Select patient", 
                                 choices = list(patient_list = patient_list),  selected = "pt02"),
                     sliderInput("center_closed", label = "Index placement of largest respiration effect during closed chest",
                                 min = 1, max = 100, value = 50),
                     sliderInput("center_open", label = "Index placement of largest respiration effect during open chest",
                                 min = 1, max = 100, value = 50),
                     tableOutput('table'),
                     tags$style(type="text/css", "#table tr td:first-child {font-weight:bold;}")),

                  
        # Main panel for displaying outputs
        mainPanel(plotOutput(outputId = "samlet_plots", height = "1200px"), tableOutput("oversigt_tabel"))
    ), 
  
    # Second page begins
    tabPanel("Info", "Created by Andreas, Casper, Mads & Simon"),
    
    # Third page begins
    tabPanel("QRS og INSP",
             sidebarPanel(h3("Inputs"),
                  sliderInput("center_open", label = "Highest point center open",
                                 min = 1, max = 100, value = 50),
                  sliderInput("center_closed", label = "Highest point center closed",
                                 min = 1, max = 100, value = 50)
             ),
             
             mainPanel( plotOutput(outputId = "insp_plot")),
                 verbatimTextOutput("maksimum_closed"),
                 verbatimTextOutput("maksimum_open"),
                 #plotOutput(outputId = "side_by_side_contour")
                 
             )
  )
)

server <- function(input, output) {
  
  # Loading data
  patient_path_open <- reactive({paste("../GAM_RDS/", input$patient, "OPEN.rds",sep="") })
  pt_data_open <- reactive({readRDS(patient_path_open(), refhook = NULL) })
  
  patient_path_closed <- reactive({paste("../GAM_RDS/", input$patient, "CLOSED.rds",sep="") })
  pt_data_closed <- reactive({readRDS(patient_path_closed(), refhook = NULL) })

  open_add_sub_value <- reactive({insp_add_sub_val(gratia::evaluate_smooth(pt_data_open(),'s(insp_rel_index)'),
                                                   input$center_open)})
  closed_add_sub_value <- reactive({insp_add_sub_val(gratia::evaluate_smooth(pt_data_closed(),'s(insp_rel_index)'), 
                                                     input$center_closed)})
  
  # For snap plots
  preds <- reactive({insp_shift_data(create_patient_preds(pt_data_open(), pt_data_closed()),
                                     open_add_sub_value(), 
                                     closed_add_sub_value())})
  snapplot <- reactive({create_viz(pred_both = preds())})


  # For stacked plots
  stackedp <- reactive({stacked_plot(
    give_it_center(gratia::evaluate_smooth(pt_data_open(),'s(insp_rel_index)'),input$center_open),
    give_it_center(gratia::evaluate_smooth(pt_data_closed(),'s(insp_rel_index)'),input$center_closed),
    gratia::evaluate_smooth(pt_data_open(),'s(qrs_rel_index)'),
    gratia::evaluate_smooth(pt_data_closed(),'s(qrs_rel_index)'))})
  
  # For contour plots
  data_open_contour <- reactive({ gratia::evaluate_smooth(pt_data_open(), 'ti(qrs_rel_index,insp_rel_index)')})
  data_closed_contour <- reactive({ gratia::evaluate_smooth(pt_data_closed(), 'ti(qrs_rel_index,insp_rel_index)')})
  
  data_contour_patient <- reactive({ create_contour_patient(data_open_contour(), data_closed_contour())})
  contour_samlet <- reactive({create_contour_viz(move_kontour(data_contour_patient(),
                                                              input$center_open,
                                                              input$center_closed),
                                                 toString(strtoi(str_sub(input$patient,-2))))})
  

  
  output$samlet_plots <- renderPlot({
    plotmatrix <- rbind(c(1,1),
                        c(2,2),
                        c(3,3))
    plotlist <- list(stackedp(), contour_samlet(), snapplot())
    if (length(plotlist)==0) return(NULL)
    grid.arrange(grobs=plotlist, layout_matrix = plotmatrix)#nrow=length(plotlist))
    
  })# renderPlot ends here
  
  
  
  ## Dette er TABLE!!
  data_time_open  <- reactive({ gratia::evaluate_smooth(pt_data_open(),   's(time_s)')})
  data_time_closed <- reactive({ gratia::evaluate_smooth(pt_data_closed(), 's(time_s)')})
  
  
  first_table <- reactive({subset(table_values, Model %in% c(paste0(input$patient, "OPEN.rds", sep=""),
                                                             paste0(input$patient, "CLOSED.rds", sep="")),
                                  select = c("Model", "CV_MAE", "Model_MAE")) })
  
  start_time <- reactive({ c(min(data_time_closed()$time_s), min(data_time_open()$time_s)) })
  end_time <- reactive({ c(max(data_time_closed()$time_s), max(data_time_open()$time_s)) })
  diff_time <- reactive({ c(max(data_time_closed()$time_s) - min(data_time_closed()$time_s), 
                            max(data_time_open()$time_s) - min(data_time_open()$time_s)) })
  
  #final_table <- reactive({cbind(first_table(), start_time(), end_time(), diff_time())})
  
  output$table <- renderTable({t(cbind(first_table(), start_time(), end_time(), diff_time()))}, rownames=TRUE, colnames=FALSE)
  
} # server slutter

OurApp <- shinyApp(ui = ui, server = server)
runApp(OurApp)
```

