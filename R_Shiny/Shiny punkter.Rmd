---
title: "Shiny punkter"
author: "Mads Varisbøl Clausen"
date: "8/2/2021"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
library(waveformtools)
library(tidyverse)
#library(mgcv)
#library(hms)
library(shiny)
library(shinythemes)
#library(shinyTime)
#library(data.table)
library(dygraphs)
```


```{r til interaktiv dygraph - denne er rigtig} 
ui = fluidPage(
  mainPanel(
    dygraphOutput("dygraph"),
    br(),
    tableOutput("table21"),
    
    plotOutput("ggplottet", click = "plot1_click",
        brush = brushOpts(
          id = "plot1_brush"
        )),
    tableOutput("table222") # det er meningen at denne ikke shower noget
  )
)

server = function(input, output) {
  
  cvp <- sample_record2$vital$Intellivue$CVP %>% 
    mutate(time_s = seconds_since_start(time)) %>%  # time_s er x værdier
    mutate(working_time = paste(substring(time, 12, 12), "6", substring(time, 14, 19), sep="")) # denne linje er til for: da vores data er blevet skubbet pga. gdpr, så skal to plots lige matche, da output-range for dygraph_signal er de originale tider (åbenbart?)

  
  output$dygraph <- renderDygraph({
    sample_record2$vital$Intellivue$CVP %>% 
      dygraph_signal()
  }) # plotter dygraph_signal
  
  cvp_reactive <- reactive({
    cvp[opdatere_start():opdatere_slut(),]
  }) # laver den reactiv, så ggplottet kan blive opdateret 
  
  output$ggplottet <- renderPlot({
   ggplot(cvp_reactive()) +
      geom_line(aes(time_s, CVP)) 
  }) #plotter ggplot med reactiv data
  

  opdatere_start <- reactive({ if (!is.null(input$dygraph_date_window))
      which(cvp$working_time %in% substring(input$dygraph_date_window[[1]], 12, 19))[1] 
  }) # tager range ud fra dygraph vha. input$dygraph_date_window, hvorefter den leder i working_time efter, hvad der er ens og vælger så den første

  opdatere_slut <- reactive({ if (!is.null(input$dygraph_date_window))
    which(cvp$working_time %in% substring(input$dygraph_date_window[[2]], 12, 19))[1]
  })  # samme som ovenover 


  
  point_clicked_row <- reactive({
    nearPoints(cvp_reactive(), input$plot1_click, maxpoints = 1, threshold = 10) 
  }) # reaktiv point
  
  output$table21 <- renderTable({
    point_clicked_row()
  }) # laver table til at show

  output$table222 <- renderTable({ 
    write.table(point_clicked_row(), 
            file = "Intervaller.csv", sep = ",", append = TRUE, quote = FALSE,
           col.names = FALSE, row.names = FALSE) #denne er lidt kontroversiel pga. renderTable, men det virker :)

  })
        
}

shinyApp(ui = ui, server = server)
```

Kører den igen..
```{r}
cvp <- sample_record2$vital$Intellivue$CVP %>% 
    mutate(time_s = seconds_since_start(time)) %>%  # time_s er x værdier
    mutate(working_time = paste(substring(time, 12, 12), "6", substring(time, 14, 19), sep=""))
```


# Dette er til efter, når man har valgt sine punkter
```{r}
intervaller_csv <- read.csv("Intervaller.csv", col.names = c("time", "CVP", "time_s", "working_time"), header = FALSE)
intervaller_csv <- unique(intervaller_csv)


for(i in 1:length(intervaller_csv$time_s)){
  intervaller_csv$index[i] <- which(abs(intervaller_csv$time_s[i]-cvp$time_s)==min(abs(intervaller_csv$time_s[i]-cvp$time_s)))
}
# man har nu index for de givne punkter - man kan så lave noget med, at den hiver dem ud i par i efter index (1,2), (3,4), (5,6) osv.
```



